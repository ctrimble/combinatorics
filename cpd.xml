<?xml version="1.0" encoding="UTF-8"?>
<pmd-cpd>
<duplication lines="122" tokens="916">
<file line="124" path="/Users/ctrimble/git/combinatorics/src/main/java/com/xiantrimble/combinatorics/Permutations.java"/>
<file line="77" path="/Users/ctrimble/git/combinatorics/src/main/java/com/xiantrimble/combinatorics/PermutationsEngine.java"/>
<codefragment>
<![CDATA[
        int windowEnd = last.length;
        int swapSource = 0;
        int swapTarget = 0;
        TYPE : for (int i = 0; i < state.length; i++) {
          switch (state[i].direction) {
            case DOWN :
              // scan the entries from back to front, looking for the first item
              // to move.
              ENTRY : for (int j = state[i].count - 1; j >= 0; j--) {
                switch (state[i].entryState[j].direction) {
                  case DOWN :
                    if (state[i].entryState[j].index < (windowEnd - windowStart - 1) - ((state[i].count - 1) - j)) {
                      // track the source index for the swap.
                      swapSource = windowStart + state[i].entryState[j].index;

                      // increment the index and deal with moving over like
                      // elements
                      state[i].entryState[j].index++;
                      for (; j < state[i].count - 1 && state[i].entryState[j].index == state[i].entryState[j + 1].index; j++) {
                        state[i].entryState[j + 1].index++;
                        state[i].entryState[j + 1].direction = Direction.DOWN;
                      }

                      // track the target index for the swap.
                      swapTarget = windowStart + state[i].entryState[j].index;
                      break TYPE;
                    }
                    state[i].entryState[j].direction = Direction.UP;
                    break;
                  case UP :
                    int startIndex = j;
                    for (; state[i].entryState[j].index == state[i].entryState[j - 1].index + 1; j--) {
                      // if this entry is moving down, then switch case
                      // statements.
                      if (state[i].entryState[j - 1].direction == Direction.DOWN) {
                        continue ENTRY;
                      }
                    }
                    swapSource = windowStart + state[i].entryState[startIndex].index;
                    state[i].entryState[j].direction = Direction.UP;
                    state[i].entryState[j].index--;
                    swapTarget = windowStart + state[i].entryState[j].index;
                    for (j++; j <= startIndex; j++) {
                      state[i].entryState[j].direction = Direction.DOWN;
                      state[i].entryState[j].index--;
                    }
                    break TYPE;
                }
              }
              // none of the entries can move down, switch directions.
              state[i].direction = Direction.UP;
              windowEnd -= state[i].count;
              if (i < state.length - 1)
                continue TYPE;
              break;
            case UP :
              // scan the entries from front to back, looking for the first item
              // to move.
              ENTRY : for (int j = 0; j < state[i].count; j++) {
                switch (state[i].entryState[j].direction) {
                  case UP :
                    if (state[i].entryState[j].index > j) {
                      // track the source index of the swap.
                      swapSource = state[i].entryState[j].index + windowStart;

                      // decrement the index and deal with moving over like
                      // elements.
                      state[i].entryState[j].index--;
                      for (; j > 0 && state[i].entryState[j].index == state[i].entryState[j - 1].index; j--) {
                        state[i].entryState[j - 1].index--;
                        state[i].entryState[j - 1].direction = Direction.UP;
                      }

                      // track the target index for the swap.
                      swapTarget = state[i].entryState[j].index + windowStart;
                      break TYPE;
                    }
                    state[i].entryState[j].direction = Direction.DOWN;
                    break;
                  case DOWN :
                    int startIndex = j;
                    for (; state[i].entryState[j].index == state[i].entryState[j + 1].index - 1; j++) {
                      // if this entry is moving down, then switch case
                      // statements.
                      if (state[i].entryState[j + 1].direction == Direction.UP) {
                        continue ENTRY;
                      }
                    }
                    swapSource = windowStart + state[i].entryState[startIndex].index;
                    state[i].entryState[j].direction = Direction.DOWN;
                    state[i].entryState[j].index++;
                    swapTarget = windowStart + state[i].entryState[j].index;
                    for (j--; j >= startIndex; j--) {
                      state[i].entryState[j].direction = Direction.UP;
                      state[i].entryState[j].index++;
                    }
                    break TYPE;
                }
              }
              state[i].direction = Direction.DOWN;
              windowStart += state[i].count;
              if (i < state.length - 1)
                continue TYPE;
              break;
          }

          // end of permutations for this combination reached. Advance to the
          // next
          // combination.
          int cur = state.length - 1;
          int remaining = 0;

          // move cur backwards to find the next item to update.
          for (; cur > 0 && (state[cur].count == 0 || state[cur].toRight < remaining + 1); remaining += state[cur--].count);

          // decrement the items at cur.
          state[cur].count--;
          remaining++;

          // move forward and update all of the counts.
          for (cur++; cur < state.length; cur++) {
            state[cur].count = Math.min(remaining, domainRanks[cur]);
]]>
</codefragment>
</duplication>
<duplication lines="27" tokens="279">
<file line="196" path="/Users/ctrimble/git/combinatorics/src/main/java/com/xiantrimble/combinatorics/IndexBasedPermutations.java"/>
<file line="75" path="/Users/ctrimble/git/combinatorics/src/main/java/com/xiantrimble/combinatorics/IndexBasedPermutationsEngine.java"/>
<codefragment>
<![CDATA[
      int windowEnd = last.length;
      TYPE: for( int i = 0; i < state.length-1; i++) {
        if( state[i].count == 0 ) continue TYPE;
        long typeCycles = index / (state[i].perms);
        long typeIndex = index % (state[i].perms);
        if( typeIndex == 0 ) {
          index = typeCycles;
          windowStart = typeCycles % 2 == 1 ? windowStart : windowStart + state[i].count;
          windowEnd = typeCycles % 2 == 0 ? windowEnd : windowEnd - state[i].count;
          continue TYPE;
        }
        
        // we are now on the proper state for this index.  On even cycles we are moving down.
        boolean down = typeCycles % 2 == 0;
        typeIndex = down ? typeIndex : (state[i].perms) - typeIndex;
        boolean elementDown = true;
        int aCount = state[i].count;
        int bCount = state[i].activeToRight;
        int aIndex = 0;
        ELEMENT: for( int elementIndex = 0; elementIndex < windowEnd - windowStart; elementIndex++) {
          long perms = elementDown ? mathUtils.p((aCount-1)+bCount, new int[]{ aCount-1, bCount}) : mathUtils.p(aCount+bCount-1, new int[]{ aCount, bCount-1});
          if( typeIndex == perms ) {
            boolean moveMultiple = ((elementIndex % 2) != (aIndex % 2)) ^ !elementDown;
            // this is the element, find the source and target.
            int source = windowStart + elementIndex;
            int target = windowStart + (moveMultiple ? elementIndex + aCount : elementIndex+1 );
            T temp = last[source];
]]>
</codefragment>
</duplication>
<duplication lines="35" tokens="167">
<file line="226" path="/Users/ctrimble/git/combinatorics/src/main/java/com/xiantrimble/combinatorics/IndexBasedPermutations.java"/>
<file line="107" path="/Users/ctrimble/git/combinatorics/src/main/java/com/xiantrimble/combinatorics/IndexBasedPermutationsEngine.java"/>
<codefragment>
<![CDATA[
          }
          else if( typeIndex < perms ^ !elementDown ) {
            typeIndex = elementDown ? typeIndex : typeIndex - perms;
            elementDown = (aIndex % 2) == (elementIndex % 2);
            aCount--;
            aIndex++;
            continue ELEMENT;
          }
          else {
            typeIndex = elementDown ? typeIndex - perms : typeIndex;
            bCount--;
            continue ELEMENT;
          }
        }
      }
      
      pastCombSize = nextIndex;
      // end of permutations for this combination reached.  Advance to the next combination.
      int cur = state.length - 1;
      int remaining = 0;
      
      // move cur backwards to find the next item to update.
      for( ; cur > 0 && (state[cur].count == 0 || state[cur].toRight < remaining+1); remaining += state[cur--].count ); // back cur up to a position to increment.
      
      // decrement the items at cur.
      state[cur].count--;
      remaining++;
      
      // move forward and update all of the counts.
      for(cur++; cur < state.length; cur++) {
        state[cur].count = Math.min(remaining, domainMultiplicity[cur]);
        remaining -= state[cur].count;
      }
      
      for( int ri = 0, ni2 = 0;ri < domainMultiplicity.length; ri++) {
]]>
</codefragment>
</duplication>
<duplication lines="32" tokens="137">
<file line="50" path="/Users/ctrimble/git/combinatorics/src/main/java/com/xiantrimble/combinatorics/CombMathUtilsImpl.java"/>
<file line="226" path="/Users/ctrimble/git/combinatorics/src/main/java/com/xiantrimble/combinatorics/CombMathUtilsImpl.java"/>
<codefragment>
<![CDATA[
    stack.addFirst(pccFactory.object().init(k, dm, dm.m, 0, 1, 1));
    
    while( !stack.isEmpty() ) {
      // get the next combination to expand.
      PartialCombinationCount pc = stack.removeFirst();
      
      //System.out.println(pc);
      
      // Start the expansion of this partial combination.
      // pc.k = the number of elements that still need to be added to the combination.
      // pc.dm = the next distinct m to consider.
      // pc.dmk = the size of the next combination of elements to add.
      // pc.ldm = the number of distinct unused elements to the left of mdi minus the number of distinct used elements at mdi.
      // pc.size = the number of combinations already in the solution (in k - pc.k)
      // pc.pd = the permutation count denominator.
      
      // get the current distinct m
      DistinctM cdm = pc.dm;
      //System.out.println(cdm);
      
      // if there could never be an answer, then bail out.
      if( pc.k > (cdm.count + pc.ldm) * pc.dmk + cdm.rn ) {
        //System.out.println("OPTIMIZED DUE TO LACK OF ELEMENTS.");
        pccFactory.recycle(pc);
        continue;
      }
      
      // for each number of pc.dmk sized sets that we can create, add new partial combinations.
      for( int e = 0; e <= pc.dm.count + pc.ldm && e * pc.dmk <= pc.k; e++ ) {
        int nextK = pc.k - (e*pc.dmk);
        int nextDmk = pc.dmk-1;
        long nextSize = pc.size * MathUtils.binomialCoefficient(pc.dm.count + pc.ldm, e);
]]>
</codefragment>
</duplication>
<duplication lines="8" tokens="127">
<file line="168" path="/Users/ctrimble/git/combinatorics/src/main/java/com/xiantrimble/combinatorics/IndexBasedPermutations.java"/>
<file line="61" path="/Users/ctrimble/git/combinatorics/src/main/java/com/xiantrimble/combinatorics/IndexBasedPermutationsEngine.java"/>
<codefragment>
<![CDATA[
          last[ni++] = domain.get(dri).get(j);
        }
      }
      for( int i = state.length - 2; i >= 0; i-- ) {
        state[i].toRight = domainMultiplicity[i+1] + state[i+1].toRight;
        state[i].activeToRight = state[i+1].activeToRight + state[i+1].count;
        state[i].perms = mathUtils.p(state[i].count+state[i].activeToRight, new int[]{ state[i].count, state[i].activeToRight});
      }
]]>
</codefragment>
</duplication>
<duplication lines="18" tokens="117">
<file line="244" path="/Users/ctrimble/git/combinatorics/src/main/java/com/xiantrimble/combinatorics/IndexBasedPermutations.java"/>
<file line="223" path="/Users/ctrimble/git/combinatorics/src/main/java/com/xiantrimble/combinatorics/Permutations.java"/>
<codefragment>
<![CDATA[
        int cur = state.length - 1;
        int remaining = 0;
        
        // move cur backwards to find the next item to update.
        for( ; cur > 0 && (state[cur].count == 0 || state[cur].toRight < remaining+1); remaining += state[cur--].count ); // back cur up to a position to increment.
        
        // decrement the items at cur.
        state[cur].count--;
        remaining++;
        
        // move forward and update all of the counts.
        for(cur++; cur < state.length; cur++) {
          state[cur].count = Math.min(remaining, domainMultiplicity[cur]);
          remaining -= state[cur].count;
        }
        
        // for now, totally reset next.  Making this an incremental update will help when the rank is much smaller than the number of entries.
        for( int ri = 0, ni = 0;ri < domainMultiplicity.length; ri++) {
]]>
</codefragment>
</duplication>
<duplication lines="30" tokens="111">
<file line="269" path="/Users/ctrimble/git/combinatorics/src/main/java/com/xiantrimble/combinatorics/Permutations.java"/>
<file line="229" path="/Users/ctrimble/git/combinatorics/src/main/java/com/xiantrimble/combinatorics/PermutationsEngine.java"/>
<codefragment>
<![CDATA[
      handler.end();
    }
  }

  private static class TypePermutationState {
    public Direction direction = Direction.DOWN;
    public EntryPermutationState[] entryState;
    public int count = 0; // the number of entries being used.
    public int toRight = 0; // the number of items that can occur to the right.
                            // Would be better with the rank array.
    public String toString() {
      return "{direction:" + direction + ", entries:" + Arrays.toString(entryState) + "}";
    }
  }

  private static class EntryPermutationState {
    public EntryPermutationState(int index) {
      this.index = index;
    }
    public Direction direction = Direction.DOWN;
    public int index = 0;
    public String toString() {
      return "{direction:" + direction + ", index:" + index + "}";
    }
  }

  private static enum Direction {
    UP, DOWN
  }
}
]]>
</codefragment>
</duplication>
<duplication lines="18" tokens="105">
<file line="125" path="/Users/ctrimble/git/combinatorics/src/main/java/com/xiantrimble/combinatorics/IndexBasedPermutationsEngine.java"/>
<file line="223" path="/Users/ctrimble/git/combinatorics/src/main/java/com/xiantrimble/combinatorics/Permutations.java"/>
<codefragment>
<![CDATA[
        int cur = state.length - 1;
        int remaining = 0;
        
        // move cur backwards to find the next item to update.
        for( ; cur > 0 && (state[cur].count == 0 || state[cur].toRight < remaining+1); remaining += state[cur--].count ); // back cur up to a position to increment.
        
        // decrement the items at cur.
        state[cur].count--;
        remaining++;
        
        // move forward and update all of the counts.
        for(cur++; cur < state.length; cur++) {
          state[cur].count = Math.min(remaining, domainMultiplicity[cur]);
          remaining -= state[cur].count;
        }
        
        // for now, totally reset next.  Making this an incremental update will help when the rank is much smaller than the number of entries.
        for( int ri = 0, ni = 0;ri < domainMultiplicity.length; ri++) {
]]>
</codefragment>
</duplication>
<duplication lines="27" tokens="103">
<file line="163" path="/Users/ctrimble/git/combinatorics/src/main/java/com/xiantrimble/combinatorics/IndexBasedPermutationsEngine.java"/>
<file line="276" path="/Users/ctrimble/git/combinatorics/src/main/java/com/xiantrimble/combinatorics/Permutations.java"/>
<codefragment>
<![CDATA[
    public Direction direction = Direction.DOWN;
    public EntryPermutationState[] entryState;
    public int count = 0; // the number of entries being used.
    public int toRight = 0; // the number of items that can occur to the right.  Would be better with the rank array.
    public String toString() {
      return "{direction:"+direction+", entries:"+Arrays.toString(entryState)+"}";
    }
  }
  
  private static class EntryPermutationState
  {
    public EntryPermutationState(int index) {
      this.index = index;
    }
    public Direction direction = Direction.DOWN;
    public int index = 0;
    public String toString() {
      return "{direction:"+direction+", index:"+index+"}";
    }
  }
  
  private static enum Direction
  {
    UP,DOWN
  }

}
]]>
</codefragment>
</duplication>
<duplication lines="8" tokens="103">
<file line="262" path="/Users/ctrimble/git/combinatorics/src/main/java/com/xiantrimble/combinatorics/IndexBasedPermutations.java"/>
<file line="143" path="/Users/ctrimble/git/combinatorics/src/main/java/com/xiantrimble/combinatorics/IndexBasedPermutationsEngine.java"/>
<codefragment>
<![CDATA[
          last[ni2++] = domain.get(ri).get(j);
        }
      }
      
      for( int i = state.length - 2; i >= 0; i-- ) {
        state[i].activeToRight = state[i+1].activeToRight + state[i+1].count;
        state[i].perms = mathUtils.p(state[i].count+state[i].activeToRight, new int[]{ state[i].count, state[i].activeToRight});
      }
]]>
</codefragment>
</duplication>
</pmd-cpd>